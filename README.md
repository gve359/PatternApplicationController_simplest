# PatternApplicationController_simplest

Обычная реализация экранных переходов(когда форма вызывает другую форму) имеет следующие проблемы:
* Для понимания топологии переходов нужно открывать код форм и искать там вызовы соседних форм.
* Для изменения топологии переходов нужно зайти в нужные формы и в них поправить ссылки на другие формы. Если форм много, то легко что-нибудь пропустить.
* Нужно изменять код форм каждый раз, когда понадобиться изменить топологию. Т.е. имеется риск повредить код даже не топологи а самой формы. Тут кстати нарушается SOLID-ные принципы «одной ответственности» - формы знают о своей организации  и «закрытости для изменения и открытости для расширения» - для смены функциональности нужно менять однажды написанный код.

Решением может стать использование паттерна Application Controller.
Согласно Мартину Фаулеру http://design-pattern.ru/patterns/application-controller.html
и Microsoft-у https://msdn.microsoft.com/en-us/library/ff709908.aspx, Application Controller это единое место управления программой и навигацией экранов графического интерфейса.

В данном проекте этот паттерн реализован таким образом: формы выставляют публичные события о том, что был запрошен переход(при этом ничего не зная о других формах). А в классе, реализующем Application Controller, по активации этих событий, отображаются соответствующие формы. 

С применением этого паттерна:
* Для понимания топологии переходов нужно просто зайти в ApplicationContoller. Там находится  полное описание переходов.
* Для изменения топологии переходов нужно поправить обработчики событий в Application Contoller-е. Т.к. они все расположены в одном месте, отследить что все необходимые замены сделаны - легче.
* Формы не хранят ссылки на соседние формы, поэтому не нужно изменять их код, ни тратить время на его просмотр.

#### Заметки по коду:
В статье https://msdn.microsoft.com/ru-ru/library/ms157901(v=vs.110).aspx, Microsoft рассказывает про ApplicationContext. Там класс MyApplicationContext занимается управлением программой и отслеживанием окон, что похоже на описание ApplicationContoller-a. Поэтому в своём проекте тоже, унаследовал ApplicationContoller от ApplicationContext(хотя и без такого наследования будет работать).
